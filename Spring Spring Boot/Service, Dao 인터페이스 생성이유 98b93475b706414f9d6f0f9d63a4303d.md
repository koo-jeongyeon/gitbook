# Service, Dao 인터페이스 생성이유

생성일: 2021년 2월 22일 오후 3:15

![Service,%20Dao%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%89%E1%85%A2%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%B2%2098b93475b706414f9d6f0f9d63a4303d/Untitled.png](Service,%20Dao%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%89%E1%85%A2%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%B2%2098b93475b706414f9d6f0f9d63a4303d/Untitled.png)

스프링에서 Service 와 Dao 의 인터페이스를 만드는 이유?

Dao 의 로직이 바뀌어 Dao1을 사용하지 않고 Dao2 를 사용하게 되었을때 Service 에서 객체생성를 해주는 부분을 직접 바꾸기 보다는 자료형을 인터페이스로 만들어 Dao d = new Dao2 이런식으로해 느슨하게 해준다

객체생성하는 new Dao2 부분은 스프링에서 자동으로 객체를 생성해 선언한 변수에 주입시킴 이걸 위해서 xml 이나 Annotaion 으로 외부 설정을 해주는것임 

이렇게해주면 DAO 에서 업무로직이 바뀐다고 해도 Service 에선 로직을 수정할 필요가 없다는걸 의미함 → 이말은 DAO 와 Service 의 로직이 완전히 분리되어 분업을 가능케 해준다는말이 된다

@Autowired 

private marsterDao marsterdao;

@Inject MasterDao MasterDao;

위나 아래와 같은 것이 자동으로 객체를 생성해 선언된 변수에 주입하는 부분임

이게 바로 DI (의존성 주입) 이고 이걸 가능하게 해준 스프링 기법이 IoC(제어의 역전) 이다

- DI (부품조립으로 생각해라)

아래것은 Composition has a 방식이라고 강한 결합을 가짐 //일체형

```java
class A {
	private B b;
	public A(){
		b = new B();
	}
}
```

이건 Association has a 라고 세팅을 해야 쓸수있어 조립형이라 함 

```java
class A {
	private B b;
	public void setB(B b){
		this.b = b;
	}
}
```

일체형 < 조립형이 결합력이 낮고 느슨함 

따로 객체를(디펜던시를)만들어 부품을 조립해줌 주입 방식은 setter 혹은 생성자가 있음

스프링은 이 부품을 조립해주는 능력이 있다 이게 스프링을 쓰는 가장 기본적인 이유

부품을 조립하려면 부품에대한 주문서가 있어야하는데 이것을 xml 혹은 나아가서 어노테이션으로 처리해주는것이다

- DI 순서
    - DI 가 생성되는 순서를 보면 Composition has a 는 큰객체 부터 생성을해서 A클래스의 객체를 생성했을때 아래 B , C , D 가 생성된것을 모름 ;;
    - 근데 Association has a 방식은 작은 객체부터 생성해서 큰 객체에 주입하고 이런 방식이라 순서가 역순임 → Inversion(역순) of Control (IoC컨테이너)

- IoC컨테이너
    - 역순으로 부품을 생성하고 조립해서 컨테이너 안에 넣어 제공